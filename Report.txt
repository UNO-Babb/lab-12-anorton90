Name: Alyssia Norton

Number of elements:

Bubble Sort
Sorted: 3.92915 seconds
Reversed: 5.64553 seconds
Random: 4.37513

Bubble Sort Early Exit
Sorted: 0.00052 seconds
Reversed: 5.90610 seconds
Random: 4.31253 seconds

Selection Sort
Sorted: 2.00273 seconds
Reversed: 1.85599 seconds
Random: 1.9694 seconds

Insertion Sort
Sorted: 0.00087 seconds
Reversed: 3.69740 seconds
Random: 2.06966 seconds

Merge Sort
Sorted: 0.01594 seconds
Reversed: 0.01633 seconds
Random: 0.02698 seconds

Questions to answer:
1) What was the worst case scenario for any sorting technique?
The worst-case scenario was Bubble Sort Early Exit on the Reversed list with a time of 5.90610 seconds.

2) The first 3 sorts have the same runtime of O(n^2). Why were the times different? Why would one be more efficient than the others?
Selection is faster as it uses the minimum amount of swaps, bubble sort  performs up to O(n^2) that slows things down 
and early exit allows it to detect an already sorted list

3) Why was merge sort so much more efficient?
Merge sort divides and conquuers the list. Divides in half until only a single element remains. Then merges/conquer the list back together.

4) The built-in sorting technique for most programming languages is known as TimSort.
This is a merge sort until the arrays have fewer than 10 elements, then it does an insertion sort. Why would this be useful?
Merge sort is efficient for large lists while insertion sort is efficient for small lists

5) What issues can you see with a recursive sorting technique like merge sort?
The primary issues are memory and  and recursion. Merge sort requires a temp hold on elements which would be an issue with larger lists. 
Also for large elements the recursive splitting creates function calls and if it reaches the limit it will crash